# План работ по шагам
## Минимум для проекта
1. Вручную запустить perf, увидеть выдачу. Написать скрипт для запуска record,
    report. Первый коммит в репозиторий.
2. Разбор perf report в скрипте. Извлечение имени приложения,
    имени объектного файла из perf report. Извлечение количества сэмплов*.
3. Формирование записей: sqlite. Сохранение perf файлов. Обновление количества
    сэмплов при повторных запусках.
4. Обнаружение бинарных файлов.
## Оптимизация
5. Конвертирование профиля. Для всех perf файлов: perf2bolt. merge-fdata.
6. Оптимизация при превышении заданного количества сэмплов. Вызов BOLT.
    Сохранение оптимизированного файла.
7. Подмена оптимизированных файлов при помощи символических ссылок.
    Сброс количества сэмплов. Флажок в бд.
## Автоматический сервис
8. systemd: создать .service и .timer.
## Применение и результаты
9. Измерение производительности для вручную собранного clang.
## Страница проекта
10. Обзор. Инструкция по установке: зависимости, сервис. Инструкция по
    мониторингу. Требования к бинарным файлам.

## Better engineering
9. Выделение функций. Выделить вызов perf, работу с бд в отдельные функции.
10. perf report: пропуск оптимизированных файлов.
11. Параметризация опций: argparse. Пути к файлам perf и бд как параметры
    командной строки.
12. Оптимизация. Печать логов BOLT.
13. Логирование. Печать всех сообщений в лог.
13. Ротация perf файлов.
14. Systemd: log rotation.
15. Выделение Buildid из объектного файла - уникальный идентификатор.
16. Пред-оптимизация. Вызов perf2bolt, сохранение fdata.
17. Пред-оптимизация. Объединение fdata (merge-fdata).
18. Пред-oптимизация. Вызов BOLT, анализ динамического покрытия.
19. Фильтрация приложений: perf record с IPC, icache/iTLB метриками.
20. БД: среднее IPC, icache MPKI, iTLB MPKI.
21. BAT mode.
22. Systemd: CPU, memory limits.
